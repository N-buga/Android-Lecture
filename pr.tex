\documentclass[12 pt]{article}
\usepackage[margin = 1cm]{geometry}
\usepackage [utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{amsthm, amsmath, amssymb}
\usepackage{xcolor}
\usepackage{hyperref}
\definecolor{mygreen}{rgb}{0,0.6,0}
\usepackage{listings}
\lstset{
  language=Java,
  tabsize=2,
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=1cm,
  escapechar=|,
  showstringspaces=false,
  commentstyle=\color{green},
  keywordstyle=\color{blue},
  stringstyle=\color{mygreen},
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  commentstyle=\usefont{T2A}{fcr}{m}{sl}
}

\renewcommand{\O}{\mathcal{O}}
\newcommand{\SO}{\Rightarrow}
\newcommand{\EQ}{\Leftrightarrow}
\newcommand{\union}{\cup}
\renewcommand{\div}{\mathop{\raisebox{-2pt}{\vdots}}}

\begin{document}

\section{Android Manifest}
    \begin{itemize}
    	\item Описание проекта, в том числе настройки и конфигурации, например версии.
    	\item Прописаны permission и составляющие проекта.
    \end{itemize}

\section{Activity}
    \begin{itemize}
    	\item Первой в программе вызывается MainActivity(? не помню).
    	\item Цикл жизни.
   		\item Activity надо прописывать в манифесте.
   	\end{itemize}

\section{BroadCastReceiver}
    ??На один и тот же интент, на один и тот же тип интента может быть очень много. И они вызываются последовательно. Если там в какой-нибудь цепочке первый взял на час захватил процессор и работает упорно, все другие будут ждать оповещения об этом.?? 
    
    BroadCastReceiver - класс-обработчик intent-ов, то есть класс-обработчик широковещательных сообщений. Он может быть подписан на несколько разных интентов. Если к нему приходит несколько интентов за раз, то они выстраиваются в цепочку и обрабатываются по-одному, поэтому есть определённые ограничения на работу BroadCastReceiver. Если вы попробуете обрабатывать интент больше 5 секунд, обработчик принудительно прикончат, чтобы другие интенты не ждали, пока их обработают. Из-за этой особенности количество действий, которое вы можете сделать с помощью BroadCastReceiver, довольно ограничено. Как правило, всё, что делают в BroadCastReceiver - это посылают другой интент, чтобы запустить Activity, Service(это такой класс, позже мы зачем он нужен и что это такое) или что-нибудь подобное. 
    
    Другое назначение BroadCastReceiver это получать системные оповещения. Есть некоторое количество системных оповещений, например о том, что андроид загрузился, или, например, у вас маленький заряд батарейки. Можно подписаться и на них и как-то среагировать. 
    
    Как и Activity, BroadCastReceiver должен быть прописан в андроид манифесте(на самом деле его можно зарегистрировать и программно, и иногда так и делают, но мы этого касаться не будем):
    \begin{lstlisting}
<receiver android:name=".LocationChangedReceiver" />
    \end{lstlisting} Теперь, надо как-то сказать приложению, на какие intent мы подписываем наш BroadCastReceiver. Вообще-то говоря, можно это сделать прямо в манифесте. Так обычно и делают, если вы подписываетесь на системные события. А можно сделать это програмно. Мы будем делать это программно:
    \begin{lstlisting}
mLocationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
Intent intent = new Intent(this, LocationChangedReceiver.class);
mLocationChangedIntent =
PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
    \end{lstlisting} Здесь я, когда создаётся Activity, получаю доступ к некоторому LocationManager, который вы уже видели раньше. Затем я создаю Intent ручками, где явно прописываю класс, куда интент должен быть отправлен. Это то, что называют explicit Intent. Вообще, интенты бывают implicit, а бывают explicit. Explicit интенты - это интенты, для которых мы явно прописываем, к какому классу его отправить, implicit - когда мы некоторым образом описываем, куда мы хотим передать сообщение, и потом уже сам андроид разбирается, кого надо запустить по этому описанию. В данном случае, мы при создании интента явно указываем класс приёмника. Соответсвенно, Intent ему и будет доставлен. 
    
    На самом деле, здесь отправляется не совсем интент, а то, что называется PendingIntent - наследник класса интент. Главное его отличие от обычного интента в том, что он учитывает права приложения. Как мы уже говорили, вы можете запускать Activity(приложение) из другого приложения, но у этого Activity(приложения) может не быть прав на работу с какими-то там ресурсами. Если эти права нужны, вы можете послать PendingIntent и передать тем самым Activity(приложению), которое вы запускаете, свои права на исполнение. Вам не всегда это нужно, но некоторые API просто по умолчанию используют PendingIntent. Понятно, что в нашем случае BroadCastReceiver это часть нашего же приложения, и у него есть все те же самые права, поэтому PendingIntent как бы и не нужен. Но дело а том, что посылаем мы его с помощью LocationManager, а интерфейс LocationManager требует PendingIntent, поэтому отправляется здесь именно PendingIntent. 
    
    Когда приходит интент, который предназначен для данного BroadCastReceiver, вызывается метод onReceive(). Одним из его аргументов является экземпляр класса Context - базовый класс для частей приложения. Он предоставляет доступ ко всем андроидовским ресурсам. Через контест вы можете обращаться к ресурсам системы. К примеру, Activity - наследник класса Context. Поэтому, мы можем вызвать, к примеру, метод getSystemService(), определённый в классе Context - для доступа к какому-то сервису. Activity является наследником класса Context, поэтому этот метод вызывается без всякого префикса. А вот BroadCastReceiver не является наследником класса Context, но доступ ко всяким менеджерам вполне себе может понадобиться, поэтому-то контекст и передаётся методу onReceive(). 
    
        В нашем Reciever мы не будем делать ничего такого, мы просто напечатаем в Log некое сообщение(что такое Log мы поподробнее ещё обсудим). 
        
        \begin{lstlisting}
public class LocationChangedReceiver extends BroadcastReceiver {

    private static final String TAG = LocationChangedReceiver.class.getSimpleName();

    public LocationChangedReceiver() { }

    @Override
    public void onReceive(Context context, Intent intent) {
        final String locationKey = LocationManager.KEY_LOCATION_CHANGED;

        if (intent.hasExtra(locationKey)) {
            Location location = (Location) intent.getExtras().get(locationKey);

            Intent startService = new Intent(context, ForecastUpdateService.class);
            startService.putExtra(LocationManager.KEY_LOCATION_CHANGED, location);
            context.startService(startService);
        }
    }
}
    \end{lstlisting}
    
    Если обобщить:
    \begin{itemize}
        \item Один из стандартных классов андроид, завязан на несколько(может один) intent. 
	    \item Получает интент, к которому он привязан и \textcolor{red}{быстро} реагирует(с технической точки зрения при получении intent вызывается onReceive(), который должен быстро выполняться).
		\item Если один BroadCastReceiver соотетствует нескольким intent, то они построятся в цепочку и будут выполняться последовательно.
		\item Поэтому если по какому-то intent метод выполняется слишком долго, то его прикончат, чтобы другие intent не ждали.
		\item Так что обычно, его используют только чтобы послать какой-то другой intent или получить системное оповещение.
 		\item Receiver должен быть прописан в Android манифесте.
        \begin{lstlisting}
<receiver android:name=".LocationChangedReceiver" />
        \end{lstlisting}		    
 	    \item Подписку на intent можно тоже записать в Manifest.
        \item А можно это сделать и програмно. Explicit intent - явно указываем класс, к которому intent отправить. Бывает ещё implicit intent. На самом деле здесь посылается не intent а наследник класса Intent - PendingIntent, в котором учитываются права приложения, из которого нас запустили. 
        \item Intent - это такой способ общаться между частями приложения. В него можно записать дополнительную информацию.
        \begin{lstlisting}
startService.putExtra(LocationManager.KEY_LOCATION_CHANGED, location);
        \end{lstlisting}        
        \item Доставать информацию из Intent можно так:
        \begin{lstlisting}
Location location = (Location) intent.getExtras().get(locationKey);
        \end{lstlisting}
        \item Класс Context - это базовый класс для частей приложения. К примеру, Activity - наследник класса Context. Он предоставляет доступ ко всем андроидовским ресурсам. BroadCastReceiver не является наследником класса Context, поэтому он туда передаётся.
    \end{itemize}

\section{Log}
    Мы открываем наш DeviceMonitor. LogCat.     
    \begin{itemize}
        \item Записи в log выводятся на экран Logcat.
        \item Логирование происходит так:
    \end{itemize}
    \begin{lstlisting}
    ...
private static final String TAG = 
            SMSReceiver.class.getSimpleName();
    ...
Log.d(TAG, "SMS received");    
    \end{lstlisting}

Усложним наш BroadCastReceiver - мы хотим при обновлении кординат качать прогноз погоды.

\section{Permissions}
    \begin{itemize}
        \item Чтобы работать с сетью надо подключить соотетсвующие permission.
        \begin{lstlisting}
<uses-permission android:name="android.permission.INTERNET" /> 
<uses-permission  android:name="android.permission.ACCESS_NETWORK_STATE"/>        
        \end{lstlisting}
    \end{itemize}
\section{Service}    
    \begin{itemize}
        \item Service также надо прописывать в манифесете:
        \begin{lstlisting}
<service
    android:name=".DatabaseService"
    android:exported="false" >
</service>        
        \end{lstlisting}
        \item Для того, чтобы делать продолжительные действия BroadCastReceiver не подходит. Для этого нужно использовать Service.
        \item Ключик exported задаёт, позволено ли другим приложениям запускать наш сервис, Activity и тд.
        \item Работает в фоновом режиме.
        \item В андроид есть класс Service, от которого можно отнаследоваться и написать свой сервис с блэк-джеком. Но иногда нам нужно от сервиса только обрабатывать приходящие к нему интенты, тогда можно отнаследоваться от IntentService и просто определить метод onHandleIntent(Intent intent), который запускается, когда приходит очередной intent.
        \item Если к нему обращаются много intent, они просто становятся в очередь.
        \item Запускают intent к service через команду startService(...);
        \item Если нам достаточно обрабатывать один intent за раз, то IntentService; если нам надо обрабатывать много intent одновременно, то реализуем наследника обычного Service.
    \end{itemize}
    
    Что мы хотим сделать в нашем сервисе? Мы хотим достучаться по сети до сайта и скачать от туда прогноз погоды по текущим координатам. Сначала идёт куча разных параметров, описывающих разметку json-класса(этого мы касаться не будем). Потом, достаём из intent информацию о текущих координатах: 
    \begin{lstlisting}
final String locationKey = LocationManager.KEY_LOCATION_CHANGED;
.....
Location location = (Location) intent.getExtras().get(locationKey);    
    \end{lstlisting} .get(...) возвращает Object, поэтому нужно явно кастить к типу, который на нужен. Затем мы долго и страшно с помощью андроидовского Uri собираем Url. А затем работаем непосредственно с сетью. Для этого поймём, как работать с сетью, как подключиться к сайту.

\section{Connection}
    \begin{itemize}
        \item Самый простой способ работать с сетью - это HttpURLConnection.
        \item Возвращается методом .openConnection(). Осторожно, этот метод возвращает не HttpURLConnection, поэтому предварительно нужно скастить возвращаемое значение к HttpURLConnection:
        \begin{lstlisting}
URL url = new URL(uri.toString());
connection = 
        (HttpURLConnection) url.openConnection();
        \end{lstlisting}
        \item Протокол http может обрабатывать различные запросы. Например, запрос на получение информации. Если мы хотим получить информацию - пишем следующее:
        \begin{lstlisting}
connection.setRequestMethod("GET");
connection.connect();
        \end{lstlisting} Вместо "GET" может быть другая строчка, в зависимости от того, какой ваш запрос к серверу. В общем случае, описание метода надо смотреть в API того сервиса, которым вы пользуетесь. 
        \item С данным типом соединения обычно происходит так - создание запроса, подключение, считывание информации из ответа(если нужно). Дальше соединение по большей части бесполезно. В конце нельзя забывать закрыть соединение: 
        \begin{lstlisting}
connection.disconnect();        
        \end{lstlisting}
    \end{itemize}
    Пример считывания информации:
    \begin{lstlisting}
InputStream inputStream = connection.getInputStream();
StringBuilder buffer = new StringBuilder();
if (inputStream == null) {
    return;
}
reader = new BufferedReader(new InputStreamReader(inputStream));
String line;
while ((line = reader.readLine()) != null) {
    buffer.append(line);
    buffer.append("\n");
}

if (buffer.length() == 0) {
    return;
}
    \end{lstlisting}
    Обычно ответ формируется либо в формате xml, либо в формате json - это два разных представления данных. В данном случае, мы используем json. Нужно этот формат распарсить и обработать - для этого мы написали функцию parseJsonData(String), но подробно на ней останавливаться не будем.
    
    Каждый раз при смене своих координат не очень разумно слать запрос в интернет. Это долго, это не надёжно - интернет или сервис могут не работать. Поэтому стоит задуматься о том, как приложение будет работать в offline-режиме. К примеру, разумный вариант - когда у нас есть доступ к сети, получать погоду и сохранять её в базу данных. А когда сети нет - просто достаём из базы данных самое актуальное значение и показываем. Оно, может быть, и устаревшее, но хоть какое-то. Соответсвенно, следующая наша цель - получить результат и сохранить его в базу данных.
\section{Data bases}
	\begin{itemize}
		\item ContentProvider - это такой класс-обёртка над базой данных.
		\item Его также надо прописывать в манифесте:
		\begin{lstlisting}
<provider
	android:authorities="edu.spbau.android.forecast"
    android:name=".WeatherProvider" />		
		\end{lstlisting}
	\end{itemize}    
	Перд тем, как подробней говорить о ContentProvider, познакомимся с ещё одним классом Contract, реализация которого является правилом хорошего тона. Там обычно описывается структура базы данных. То есть, он необязателен, чтобы работать с базами данных, но лучше его реализовывать.
	Соответсвенно:
	\begin{itemize}
	    \item Его не надо прописывать в манифесте, так как это вспомогательный класс.
	    \item Там как константы хранятся названия таблиц, названия колонок, строк и другая подобная информация.
	    \item Для каждой таблички внутри контракта заводится класс-наследник интерфейса BaseColumns. И в нём уже описывается вся информация о конкретной табличке. 
	    \item В нашей базе данных будет только одна табличка, в которой будет храниться прогноз погоды по времени.
	    \item В этом классе необходимо определить: 
	    \begin{itemize}
	        \item public static final Uri CONTENT\_URI -- Uri, по которому мы будем обращаться к ContentProvider, так как доступ к ContentProvider осуществляется только через Uri. 
	        \item public static final String CONTENT\_TYPE -- тип набора записей в ContentProvider.
	        \item public static final String CONTENT\_ITEM\_TYPE -- тип одной записи в ContentProvider
	    \end{itemize}
	    Последние два вегда выглядят одинаково, но их всё равно приходится прописывать.
	    \item Также, в классе прописываются разные служебные методы. У нас реализованы преобразование даты в Uri, и наоборот. Чтобы мы смогли потом обратиться к какой-то записи, соотетсвующей определённой дате.
	\end{itemize}
	
	Наш Contract выглядит так:
	\begin{lstlisting}
public class WeatherContract {

    public static final String CONTENT_AUTHORITY = "edu.spbau.android.forecast";
    public static final Uri BASE_CONTENT_URI = Uri.parse("content://" + CONTENT_AUTHORITY);
    public static final String PATH_WEATHER = "weather";

    public static long normalizeDate(long gmt) {
        Time time = new Time();
        time.set(gmt);
        int day = Time.getJulianDay(gmt, time.gmtoff);
        return time.setJulianDay(day);
    }

    public static final class WeatherEntry implements BaseColumns {

        public static final Uri CONTENT_URI =
                BASE_CONTENT_URI.buildUpon().appendPath(PATH_WEATHER).build();

        public static final String CONTENT_TYPE =
                ContentResolver.CURSOR_DIR_BASE_TYPE + "/" + CONTENT_AUTHORITY + "/" + PATH_WEATHER;

        public static final String CONTENT_ITEM_TYPE =
                ContentResolver.CURSOR_ITEM_BASE_TYPE + "/" + CONTENT_AUTHORITY + "/" + PATH_WEATHER;

        public static final String TABLE_NAME = "weather";

        public static final String COLUMN_DATE = "date";
        public static final String COLUMN_DAY_TEMP = "day_temp";
        public static final String COLUMN_NIGHT_TEMP = "nigh_temp";
        public static final String COLUMN_WIND_SPEED = "wind";
        public static final String COLUMN_DEGREES = "direction";
        public static final String COLUMMN_WEATHER_ID = "weather_id";

        public static long getDateFromUri(Uri uri) {
            return Long.parseLong(uri.getPathSegments().get(1));
        }

        public static Uri buildWeatherUri(long date) {
            return ContentUris.withAppendedId(CONTENT_URI, date);
        }

    }

}	
	\end{lstlisting}
	
	Следующий класс, про который мы поговорим перед ContentProvider, это абстрактный класс \\ SQLiteOpenHelper.
	\begin{itemize}
	    \item Это, собственно, тот класс, который работает с базой данных. Именно через этот класс, мы будем делать запросы к бд.
	    \item Как нетрудно догадаться по названию, в Android используется SQLite, который нам подаётся обёрнутым в интерфейс.
	    \item Также, именно через него мы создаём базу данных в первый раз. При первом запуске у \\ SQLiteOpenHelper вызывается метод public void onCreate(SQLiteDatabase db), в котором мы создаём базу данных с помощью запросов к SQLiteDatabase.
	    \item В классе нужно переопределить также метод public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion), который позволяет обновить базу данных в процессе работы приложения. Как-то изменять структуру или добавлять новый таблички, к примеру. 
	    
	    Внутри каждого запроса к базе данных есть также поле версии, в которой описано, какой версии должна соответвовать база данных. И, если текущая версия базы данных не соответсвует той, которую ожидает приложение, будет вызван метод onUpgrade(oldVersion - текущая версия бд, newVersion - версия, требуемая приложением).
	    
	    Самый простой способ изменить бд - это удалить всё и создать заново, что мы, собственно, и делаем. Надо учитывать при этом, что мы при таком подходе теряем все данные. Но в нашем случае, нам это не важно.
	\end{itemize}
	
	Мы наследуемся от SQLiteOpenHelper следующим образом:
	\begin{lstlisting}
public class WeatherDBHelper extends SQLiteOpenHelper {

    private static final int DATABASE_VERSION = 1;
    private static final String DATABASE_NAME = "weather.db";

    public WeatherDBHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        String SQL_CREATE_WEATHER_TABLE = "CREATE TABLE " + WeatherEntry.TABLE_NAME + " (" +
            WeatherEntry._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
            WeatherEntry.COLUMN_DATE + " INTEGER NOT NULL," +
            WeatherEntry.COLUMN_DAY_TEMP + " REAL NOT NULL," +
            WeatherEntry.COLUMN_NIGHT_TEMP + " REAL NOT NULL," +
            WeatherEntry.COLUMN_WIND_SPEED + " REAL NOT NULL," +
            WeatherEntry.COLUMN_DEGREES + " REAL NOT NULL," +
            WeatherEntry.COLUMMN_WEATHER_ID + " INTEGER NOT NULL, " +
                "UNIQUE (" + WeatherEntry.COLUMN_DATE + ") ON CONFLICT REPLACE);";

        db.execSQL(SQL_CREATE_WEATHER_TABLE);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS " + WeatherEntry.TABLE_NAME);
        onCreate(db);
    }

}
	\end{lstlisting}
	
	Теперь, наконец, разберём поподробнее класс ContentProvider:
	\begin{itemize}
	    \item Мы создадим класс-наследник от ContentProvider - WeatherProvider. У ContentProvider можно переопределить только метод onCreate - так как именно там обычно происходит подключение к базе данных, но и этот метод переопределять необязательно. 
	    \item В нашем случае, подключение к бд - это просто создание WeatherDBHelper.
	    \begin{lstlisting}
@Override
public boolean onCreate() {
    mDbHelper = new WeatherDBHelper(getContext());
    return true;
}	    
	    \end{lstlisting}
	    \item public Cursor query(...) - вызывается при запросе к ContentProvider(читай, к бд). Здесь обрабатываются запросы типа SELECT.
	    \item public Uri insert(...) - вызывается, если мы хотим вставить что-то в ContentProvider(читай, нашу бд). Здесь обрабатываются запросы типа INSERT.
	    \item public int delete(...) - вызывается, если мы хотим удалить что-то из ContentProvider(читай, из нашей бд). Здесь обрабатываются запросы типа DELETE.
	    \item public int update(...) - вызывается, если мы хотим обновить какую-то запись в ContentProvider(читай, в нашей бд). Здесь обрабатываются запросы типа UPDATE.
	    \item public int bulkInsert(...) - метод, позволяющий вставлять сразу пачку значений(запросы типа INSERT).
	    \item public String getType(Uri uri). Метод берёт Uri, на который может отвечать наш ContentProvider, и возвращает по нему тип записи для этого Uri. В нашем случае, для возвращаемого значения может быть только два варианта. Либо, это специфичный Uri, который указывает на одну запись, либо он указывает сразу на группу записей. Тип Uri определяется с помощью утилитарного класса UriMatcher, который проверяет Uri относительно некоторых шаблонов для Uri и возвращает соответсвующий код. 
	    
	    В нашем случае, метод работает следующим образом - если в качестве Uri передаётся запись, в конце которой имя нашей таблички, то мы возвращаем тип множественный(то есть это запрос ко всем элементам таблички), а если через слеш записано какое-то число, то тип Uri - тип одной записи(число мы потом преобразуем в дату и вернём значение, соответсвующее этой конкретной дате).
	    \begin{lstlisting}
@Override
public String getType(Uri uri) {
    switch (sUriMatcher.match(uri)) {
        case WEATHER:
            return WeatherContract.WeatherEntry.CONTENT_TYPE;
        case WEATHER_WITH_DATE:
            return WeatherContract.WeatherEntry.CONTENT_ITEM_TYPE;
        default:
            throw new UnsupportedOperationException("Unknown uri: " + uri);
    }
}
	    \end{lstlisting}
	    \item Закрывать базу данных не нужно, несмотря на то, что, казалось бы, работа с базой данных - это практически то же самое, что работа с файлами. Есть метод, который позволяет это сделать, но он создан исключительно для дебага.
	\end{itemize}
	Поподробнее о методах:
	\begin{itemize}
    	\item query. Допустим пользователь вызвал query. Сначала мы определяем тип этого запроса по Uri - конкретная запись, конкретная запись с какими-то параметрами или группа записей. Затем вызываем соответсвующие методы, в которых уже в зависимости от типа делаем запросы(query) к бд. В этой query projection задают колонки, которые мы котим получить; selection - это условие, по которому мы выбираем; selectionArgs - конкретные значения для условия и т.д. Для того, чтобы прочитать что-нибудь из базы данных, мы используем метод .getReadableDatabase().
    	\begin{lstlisting}
private Cursor getWeather(String[] projection, String selection, String[] selectionArgs, String sortOrder)
{
    return mDbHelper.getReadableDatabase().query(WeatherContract.WeatherEntry.TABLE_NAME,
            projection,
            selection,
            selectionArgs,
            null,
            null,
            sortOrder);
}

private Cursor getWetherByDate(Uri uri, String[] projection, String sortOrder) {
    long date = WeatherContract.WeatherEntry.getDateFromUri(uri);
    String selection = WeatherContract.WeatherEntry.COLUMN_DATE + " = ? ";
    String selectionArgs[] = new String[] { Long.toString(date) };

    return mDbHelper.getReadableDatabase().query(WeatherContract.WeatherEntry.TABLE_NAME,
            projection,
            selection,
            selectionArgs,
            null,
            null,
            sortOrder);
}
            ...           
@Override
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
    Cursor cursor;
    switch (sUriMatcher.match(uri)) {
        case WEATHER:
            cursor = getWeather(projection, selection, selectionArgs, sortOrder);
            break;
        case WEATHER_WITH_DATE:
            cursor = getWetherByDate(uri, projection, sortOrder);
            break;
        default:
            throw new UnsupportedOperationException("Unknown uri: " + uri);
    }
    cursor.setNotificationUri(getContext().getContentResolver(), uri);
    return cursor;
}    	
    	\end{lstlisting}
	    \item insert. Чтобы записать что-либо в базу данных, мы используем метод .getWritableDatabase(). Принцип точно такой же - мы не пишем явно SQL-запрос, мы передаём только параметры.
	    \begin{lstlisting}
@Override
public Uri insert(Uri uri, ContentValues values) {
    switch (sUriMatcher.match(uri)) {
        case WEATHER:
            normalizeDate(values);
            long date = values.getAsLong(WeatherContract.WeatherEntry.COLUMN_DATE);
            long id = mDbHelper.getWritableDatabase().insert(
                    WeatherContract.WeatherEntry.TABLE_NAME, null, values);
            if (id != -1) {
                getContext().getContentResolver().notifyChange(uri, null);
                return WeatherContract.WeatherEntry.buildWeatherUri(date);
            } else {
                throw new android.database.SQLException("Failed to insert row into " + uri);
            }
        default:
            throw new UnsupportedOperationException("Unknown uri: " + uri);
    }
}	    
	    \end{lstlisting}
	\end{itemize}
	Хорошо бы после изменения чего-либо в базе данных оповестить тех, кто использует данные, об этом. Для этого есть метод .notifyChange(uri, null), вызывающийся так:
    \begin{lstlisting}
getContext().getContentResolver().notifyChange(uri, null);    
    \end{lstlisting} Этому методу передаётся Uri, по которому мы что-то изменили.
    
    В общем, ContentProvider - это просто класс, который делает запросы к базе данных, скрывая это за интерфейсом Uri.
    
    Общая реализация ContentProvider: \href{https://github.com/krinkinmu/forecast/blob/master/app/src/main/java/edu/spbau/android/forecast/WeatherProvider.java}{тык}
\section{Fragments}
    \begin{itemize}
        \item Весь UI в большинстве приложений распихан по фрагментам.
    \end{itemize}   
    ListView и Adapter - это в некотором смысле андроидовская реализация того, что называют Model-View Controller.
    
    Идея в следующем - есть какая-то View, рисующая UI. Есть набор данных, по которым этот UI рисуется. И они разделены по разным классам. Таким образом, мы, например, можем подменить один View другим, не меняя модельку, в которой эти данные хранятся.
\section{ListView}
    \begin{itemize}
        \item Для того, чтобы рисовать списки, используют ListView.
    \end{itemize}
\section{Adapter}
    \begin{itemize}
        \item Adapter - класс, который предоставляет нам доступ к данным. А так как у нас есть база данных, то в нашем случае мы хотим, чтобы Adapter предоставлял нам доступ к нашей базе данных. Для этого в Android есть специальный класс, называемый CursorAdapter(он, например, при обновлении бд оповещает View об этом).
        \item При создании CursorAdapter необходимо переопределить несколько методов - public View newView(...), public void bindView(...).
        \item public View newView(Context context, Cursor cursor, ViewGroup parent) - создаёт новую View. Вызывается, когда для каких-то данных в ListView надо добавить новое View. context - для доступа к системным ресурсам. cursor - указывает на текущую строчку в базе данных(на ту строчку, для которой мы хотим создать новую View). parent - элемент, внутрь которого мы должны новую View положить.
        \begin{lstlisting}
@Override
public View newView(Context context, Cursor cursor, ViewGroup parent) {
    View view = LayoutInflater.from(context).inflate(R.layout.forecast_list_item_view,
            parent, false);
    view.setTag(new ViewHolder(view));
    return view;
}        
        \end{lstlisting}
        \item LayoutInflater - это сущность, которая по xml-описанию View создаёт эту View. 
        
        Пример xml-описания:
        \begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:gravity="center_vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="20dp">

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1">

        <TextView
            android:id="@+id/date"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="10dp"/>

        <TextView
            android:id="@+id/wind"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="10dp"/>

    </LinearLayout>

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:gravity="right">
        
        <ImageView
            android:id="@+id/icon"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="10dp"/>

        <TextView
            android:id="@+id/temp"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="10dp"/>

    </LinearLayout>

</LinearLayout>    
        \end{lstlisting} 
        
        Здесь, внешний LinearLayout - это такая Group, в которую добавленные элементы горизонтально(android:orientation="horizontal") ложаться друг за другом.
        
        Два внутренних LinearLayout - это аналогичные Group, только элементы ложаться по вертикали(android:orientation="vertical").
        
        TextView - это просто текст.
        
        ImageView - это картиночка.
        
        Надо заметить, что View - это какая-то рисуемая сущность, а Group - сущность разметки, то есть она размещает по каким-то правилам View или другие Group. Так вот все *Layout - это Group.
        
        У каждого элемента можно задать id, по которому впоследствии его можно будет найти. Без id элемент найти будет трудно, поэтому если какой-то элемент используется или изменяется в коде, ему обязательно нужно дать своё id.
        \item Можно размечать экран и с помощью кода, создавая Layout-ы и View на ходу, но xml в некотором смысле практичней, поскольку мы просто можем заменить один layout другим без изменения кода.
        \item Итак, LayoutInflater получает xml-файл, создаёт дерево объектов и возвращает корневой.
        \item Рядом с любой View мы можем хранить данные, добавляя их с помощью метода .setTag(Data data);
        \item ViewHolder, который мы добавляем в качестве дополнительной информации к View, один раз находит нужные нам View, которые мы будем изменять, и кеширует их, чтобы не приходилось какждый раз бегать по дереву объектов. Это действительно помогает, потому newView не всегда вызывается, когда на экране появляется очередная View. Андроид располагает небольшими ресурсами, поэтому созданные View он может переиспользовать, подав их же ещё раз на вход bindView. Например, так происходит при прокручивании списка.
        \item Следующий метод, про который нам надо поговорить - public void bindView(View view, Context context, Cursor cursor). bindView связывает View с данными, которые мы хотим на ней отобразить. То есть bindView в нашем случае должен заполнить поля у текстовых View, которые отвечают за температуру, чтобы они отображали актуальный данные.
    \end{itemize}
\end{document}

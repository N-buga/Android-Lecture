\documentclass[utf8]{beamer}
\usepackage [utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{amsthm, amsmath, amssymb}
\usepackage{xcolor}
\definecolor{mygreen}{rgb}{0,0.6,0}
\usepackage{listings}
\lstset{
  language=Java,
  tabsize=2,
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=1cm,
  escapechar=|,
  showstringspaces=false,
  commentstyle=\color{green},
  keywordstyle=\color{blue},
  stringstyle=\color{mygreen},
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  commentstyle=\usefont{T2A}{fcr}{m}{sl}
}

\renewcommand{\O}{\mathcal{O}}
\newcommand{\SO}{\Rightarrow}
\newcommand{\EQ}{\Leftrightarrow}
\newcommand{\union}{\cup}
\renewcommand{\div}{\mathop{\raisebox{-2pt}{\vdots}}}

\usetheme{Madrid}
\useoutertheme{shadow}
\title{Заголовок}
\date{Дата или место проведения}
\author{Автор}
\begin{document}
% титульная  страница
\begin{frame}
    \titlepage
\end{frame}

%структурная разметка
\section{Android Manifest}
\begin{frame}
    \frametitle{Android Manifest}
    \begin{itemize}
    	\item Описание проекта, в том числе настройки и конфигурации, например версии.
    	\item Прописаны permission и составляющие проекта.
    \end{itemize}
\end{frame}

\section{Activity}
\begin{frame}
    \frametitle{Activity}
    \begin{itemize}
    	\item Первой в программе вызывается MainActivity(? не помню).
    	\item Цикл жизни.
   		\item Activity надо прописывать в манифесте.
   	\end{itemize}
\end{frame}

\section{BroadCastReceiver}
\begin{frame}
    %заголовок слайда
    \frametitle{BroadCastReceiver}
    \begin{itemize}
        \item Один из стандартных классов андроид, завязан на несколько(может один) intent. 
	    \item Получает интент, к которому он привязан и \alert{быстро} реагирует(с технической точки зрения при получении intent вызывается onReceive(), который должен быстро выполняться).
		\item Если один BroadCastReceiver соотетствует нескольким intent, то они построятся в цепочку и будут выполняться последовательно.
		\item Поэтому если по какому-то intent метод выполняется слишком долго, то его прикончат, чтобы другие intent не ждали.
		\item Так что обычно, его используют только чтобы послать какой-то другой intent или получить системное оповещение.
 		\item Receiver должен быть прописан в Android манифесте.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BroadCastReceiver}
    \begin{itemize}    
 	    \item Подписку на intent можно тоже записать в Manifest.
 	\end{itemize}
    \begin{lstlisting}
<receiver android:name=".LocationChangedReceiver" />
    \end{lstlisting}		    
\end{frame}
\begin{frame}[fragile]
    \begin{itemize}
        \item А можно это сделать и програмно. Explicit intent - явно указываем класс, к которому intent отправить. Бывает ещё inplicit intent. На самом деле здесь посылается не intent а наследник класса Intent - PendingIntent, в котором учитываются права приложения, из которого нас запустили. 
        \item Intent - это такой способ общаться между частями приложения. В него можно записать дополнительную информацию.
        \begin{lstlisting}
startService.putExtra(LocationManager.KEY_LOCATION_CHANGED, location);
        \end{lstlisting}        
        \item Доставать информацию из Intent можно так:
        \begin{lstlisting}
Location location = (Location) intent.getExtras().get(locationKey);
        \end{lstlisting}
        \item Класс Context - это базовый класс для частей приложения. К примеру, Activity - наследник класса Context. Он предоставляет доступ ко всем андроидовским ресурсам. BroadCastReceiver не является наследником класса Context, поэтому он туда передаётся.
    \end{itemize}
\end{frame}
\begin{frame}[fragile]
    \frametitle{BroadCastReceiver}
    Пример onReceive():
    \begin{lstlisting}[basicstyle=\tiny]
@Override
public void onReceive(Context context, Intent intent) {
    final String locationKey = LocationManager.KEY_LOCATION_CHANGED;

    if (intent.hasExtra(locationKey)) {
        Location location = 
                    (Location) intent.getExtras().get(locationKey);

        Intent startService = 
                        new Intent(context, ForecastUpdateService.class);
        startService.putExtra(LocationManager.KEY_LOCATION_CHANGED, location);
        context.startService(startService);
    }
} 
    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Log}
    \begin{itemize}
        \item Записи в log выводятся на экран Logcat.
        \item Логирование происходит так:
    \end{itemize}
    \begin{lstlisting}
    ...
private static final String TAG = 
            SMSReceiver.class.getSimpleName();
    ...
Log.d(TAG, "SMS received");    
    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Permissions}
    \begin{itemize}
        \item Чтобы работать с сетью надо подключить соотетсвующие permission.
        \begin{lstlisting}
<uses-permission android:name="android.permission.INTERNET" /> 
<uses-permission  android:name="android.permission.ACCESS_NETWORK_STATE"/>        
        \end{lstlisting}
    \end{itemize}
\end{frame}
\section{Service}    
\begin{frame}[fragile]
    \frametitle{Service}
    \begin{itemize}
        \item Service также надо прописывать в манифесете:
        \begin{lstlisting}
<service
    android:name=".DatabaseService"
    android:exported="false" >
</service>        
        \end{lstlisting}
        \item Для того, чтобы делать продолжительные действия BroadCastReceiver не подходит. Для этого нужно использовать Service.
        \item Ключик exported задаёт, позволено ли другим приложениям запускать наш сервис, Activity и тд.
    \end{itemize}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Service}
    \begin{itemize}
        \item Если к нему обращаются много intent, они также становятся в очередь.
        \item Запускают intent к service через команду startService(...);
        \item При обработке intent запускается метод onHandleIntent(Intent intent);
    \end{itemize}
\end{frame}
\section{Connection}
\begin{frame}[fragile]
    \frametitle{Connection}
    \begin{itemize}
        \item Самый простой способ работать с сетью - это HttpURLConnection.
        \item Возвращается методом .openConnection():
        \begin{lstlisting}
URL url = new URL(uri.toString());
connection = 
        (HttpURLConnection) url.openConnection();
        \end{lstlisting}
        \item Протокол http может обрабатывать различные запросы. Например, запрос на получение информации. Если мы хотим получить информацию - пишем следующее:
        \begin{lstlisting}
connection.setRequestMethod("GET");
connection.connect();
        \end{lstlisting}
    \end{itemize}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Connection}
    Пример считывания информации:
    \begin{lstlisting}[basicstyle=\tiny]
InputStream inputStream = connection.getInputStream();
StringBuilder buffer = new StringBuilder();
if (inputStream == null) {
    return;
}
reader = new BufferedReader(new InputStreamReader(inputStream));
String line;
while ((line = reader.readLine()) != null) {
    buffer.append(line);
    buffer.append("\n");
}

if (buffer.length() == 0) {
    return;
}
    \end{lstlisting}
\end{frame}
\end{document}
